from collections import Counter
from pot_prompt import ProgramOfThoughts
from php_prompt import ProgressiveHint
import func_timeout


class ProPlusPrompt(ProgramOfThoughts):
    """
    Based on pot and php prompt, we design a new prompt called PPP (ProPlusPrompt).
    We use php's answer to verify pot's answer.
    """

    def __init__(self, llm, record_path):
        super().__init__(llm, record_path, 8)
        self.php = ProgressiveHint(llm, record_path, 8)
        self.max_times = 10
        self.prompt_path = 'prompt/pot_prompt_improve.txt'
        self.system_prompt = """Your task is to solve math word problems using Python code. 
Provide only runnable Python code."""

    def get_prompt_list(self):
        """
        read and transform the prompt text into a list of qa tuples
        """
        with open(self.prompt_path, 'r') as f:
            prompt_text = f.read()
            qa_list = prompt_text.split('\n\n')
            n_shots_list = []
            for qa in qa_list:
                qa = qa.split('# solution using Python:')
                n_shots_list.append((qa[0].strip(), qa[1].strip()))
            return n_shots_list

    def answer_prompt(self, answer):
        return f'# solution using Python\n{answer}'

    def pro_plus_prompt(self, data):
        llm_answer = None
        result_counter = Counter()
        total_completion_tokens = 0
        total_time = 0.0
        all_generated = []
        prompt = ''
        for i in range(self.max_times):
            # use two methods to get the answer
            llm_answer_pot, tokens_pot, time_pot, generated_pot, prompt_pot = self.program_of_thought(data)
            llm_answer_php, tokens_php, time_php, generated_php, prompt_php = self.php.progressive_hint(data)
            total_completion_tokens += tokens_pot + tokens_php
            total_time += time_pot + time_php
            all_generated.extend(generated_pot)
            all_generated.extend(generated_php)
            prompt = [prompt_pot, prompt_php]
            # get same answer, return
            if llm_answer_pot == llm_answer_php:
                llm_answer = llm_answer_pot
                break
            # different answers -> get majority vote
            if llm_answer_pot is not None:
                result_counter.update([llm_answer_pot])
            if llm_answer_php is not None:
                result_counter.update([llm_answer_php])
        if llm_answer is None:
            if len(result_counter) > 0:
                llm_answer = result_counter.most_common(1)[0][0]
            else:
                llm_answer = None
        return llm_answer, total_completion_tokens, total_time, all_generated, prompt

    def evaluation(self, data):
        llm_answer, total_completion_tokens, total_time, all_generated, prompt = self.pro_plus_prompt(data)
        # convert the answer into numerical form
        answer = self.convert_answer(data['answer'])
        print('question', data['question'])
        print('answer vs llm_answer', answer, llm_answer)
        self.record_evaluation(data['question'], prompt, all_generated, answer, llm_answer, total_completion_tokens,
                               total_time)
        return llm_answer == answer

    def safe_execute(self, code_string: str):
        """
        run the code generated by llm
        """
        def execute(x):
            try:
                global_scope = {}
                local_scope = {}
                exec(x, global_scope, local_scope)
                return local_scope.get('solution')()
            except Exception:
                return None
        try:
            ans = func_timeout.func_timeout(5, execute, args=(code_string,))
        except func_timeout.FunctionTimedOut:
            ans = None

        return ans

